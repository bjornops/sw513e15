\subsection{Node}
The \texttt{Node} class is used as a static class, which means that no instances of it is made, whereas instead all methods and variables are bound to the class itself. This class determines the action to take when a packet is received, which takes place in the function \texttt{void handlePacket(Packet packet)}, with a \texttt{switch} statement deciding with the packet type as argument.

\texttt{Node} also makes sure that packets are transferred correctly. This means sending packets until an acknowledgment or other confirmation is received. To achieve this, exponential backoff is used, as explained in chapter \ref{cha:expbackoff}.

The implementation of the \texttt{Node} classes are different on the main node and sensor nodes, which is explained in the following two sections.

\subsection{Sensor nodes} 
The passive state of the sensor node is listening for packets. When a packet is received, it is handled in \texttt{void handlePacket(Packet packet)}.  

Listing \ref{lst:mainswitch} contains the main switch determining what actions to take when a packet is received. 
\begin{lstlisting}[language=C,caption={The packet handling method.},label={lst:mainswitch}]
void Node::handlePacket(Packet packet)
{
    switch (packet.packetType)
    {
        case DataRequest: // Received request
        {
            if (parentID == -1 && packet.value1 > 0 )
            {
                handleDataRequest(packet);
            }
        }
        break;
        case Data: // Received data to relay
        {
            if (parentID != -1 && packet.addressee == Node::nodeID)
            {
                handleData(packet);
            }
        }
        break;
        case PairRequestAcknowledgement: // Received ID
        {
            handlePairRequestAcknowledgement(packet);
        }
        break;
        case ClearSignal: // Clear parent and stop sending!
        {
            if (parentID != -1)
            {
                handleClearSignal(packet);
            }
        }
        break;
        default: // Handle everything else (Timeout is handled here)
        {
            handleDefault();
        }
        break;
    }
}
\end{lstlisting}
The cases first determines whether to act on the packet, and then calls the appropriate method. For example when a request is received, the action is only taken if the node has no parent ID, and the packet lifespan is higher than 0. Acknowledgments are not handled in this method, though. It is instead handled in the method that sends data to the node parent, as this is the only place where acknowledgments are relevant, in the method \texttt{void beginBroadcasting(Packet packet)}, which handles both relaying and sending data.


\subsubsection*{Exponential backoff}
In the solution, a response is often wanted when sending a packet, and exponential backoff is implemented to make sure that the packet is eventually received. This is used when sending data and waiting for an acknowledgement, or listening for a clear signal.

The code in listing \ref{lst:expbackoff} shows how a delay is calculated based on the current attempt.
The upper bound is calculated by doing $1 \cdot 2^{(attemptNumber-1)}$, and the delay is chosen by generating a random number between 1 and the upper bound.

\begin{lstlisting}[language=C,caption={Exponential backoff on the sensor nodes. In Node.cpp.},label={lst:expbackoff}]
unsigned long Node::nextExponentialBackoff(int attemptNumber)
{
    attemptNumber = (attemptNumber <= 32) ? attemptNumber : 32;
    
    unsigned long potentiallyBiggest = ((unsigned long)1 << (attemptNumber - 1));
    unsigned long delay = random(1, potentiallyBiggest);
    delay = (delay < 5) ? 5 : delay;
    
    return delay;
}
\end{lstlisting}
The variable \texttt{attemptNumber} is capped at 32, as there is 32 bits in the datatype \texttt{long} on the Arduino, and bitshifting out of the bound, causing overflow, could cause unwanted results.

Before the delay is returned, the value is set to five if it is lower than five. This is done as 1ms is not enough time for the devices to send, decode, handle, encode and sending a response. Tests showed that acknowledgements for packets being sent with a delay of 1ms were never received, so the packet had to be re-sent. Therefore 5ms was chosen as the lower bound.

\subsection{Main node} \label{cha:signalhandling}
When a packet is received, the values are saved, until all nodes have been accounted for, or a timeout is reached. If a timeout is reached, the data received from nodes will be saved along with a -1 value for the nodes that have not sent any sensor values.

Pairing sensor nodes is done on the main node by generating a unique ID and transmitting it to the sensor node requesting the ID. If no pair requests are received within ten seconds, a new ID will be generated. A file on the main node is used to store IDs and names for the sensor nodes in the network.

When a data request is completed, the data is saved to a file, with the name set as the current date and time. Another file is saved, which is used to determine if a request is done in the web interface, as explained in chapter \ref{cha:webinterface}. A request is started when a signal of the type \texttt{SIGUSR1} is received. This, asynchronously, sets a flag, \texttt{signalReceived} in \texttt{Node} to 1. Each iteration of the main loop will check \texttt{signalReceived}, and if set to 1, the requesting will be performed, and the flag set back to 0.
