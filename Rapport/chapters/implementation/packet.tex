\subsection{Packet}
The \texttt{Packet} class contains the data from a packet received from the radio module. It can be instantiated with a string, or with every part of the packet as a parameter, using the constructors in Listing \ref{lst:packetconstructors}.
\begin{lstlisting}[language=C,label={lst:packetconstructors},caption={Packet constructors}]
Packet::Packet(PacketType packetTypeInput, uint16_t addresserInput, uint16_t addresseeInput, uint16_t originInput, uint16_t value1Input,
	uint16_t value2Input, uint16_t value3Input)
	
Packet::Packet(char *input)
\end{lstlisting}


This class is passed around in \texttt{Node}, where it is used to determine actions based on the type, or being relayed with some new data. 
The class itself contains the variables:
\begin{figure}
\begin{lstlisting}
PacketType packetType; // The type of the packet
uint16_t addresser; // The sender of the packet (node ID)
uint16_t addressee; // The receiver of the packet (node ID)
uint16_t origin; // The original sender of the packet
uint16_t value1; // Value 1 (Used for sensor value)
uint16_t value2; // Value 2
uint16_t value3; // Value 3
uint16_t checksum; // Checksum value
\end{lstlisting}
\end{figure}
These values cover everything in a packet; the type, the sender, the receiver, the origin of the packet, values and a checksum.
Every packet has this format, and all values are filled out. With packets that might not require all these values, they will simply be zero. For example when sending a request, the sensor values and addressee will be zero.

\begin{table}[]
\centering
\begin{tabular}{|l|c|l|c|l|c|l|c|l|}
\hline
\textbf{Datatype} & \multicolumn{2}{c|}{Packettype}      & \multicolumn{2}{c|}{uint16\_t}       & \multicolumn{2}{c|}{uint16\_t}       & \multicolumn{2}{c|}{uint16\_t}       \\ \hline
\textbf{Name}     & \multicolumn{2}{c|}{packetType}      & \multicolumn{2}{c|}{addresser}       & \multicolumn{2}{c|}{addressee}       & \multicolumn{2}{c|}{origin}          \\ \hline
\textbf{Memory}   & \multicolumn{1}{l|}{8 bits} & 8 bits & \multicolumn{1}{l|}{8 bits} & 8 bits & \multicolumn{1}{l|}{8 bits} & 8 bits & \multicolumn{1}{l|}{8 bits} & 8 bits \\ \hline
\end{tabular}
\caption{Overview of first half of a packet. The packet can be directly converted to 16 characters.}
\label{tab:packetTableFirst}
\end{table}

\begin{table}[]
\centering
\begin{tabular}{|l|c|l|c|l|c|l|c|l|}
\hline
\textbf{Datatype} & \multicolumn{2}{c|}{uint16\_t}       & \multicolumn{2}{c|}{uint16\_t}       & \multicolumn{2}{l|}{uint16\_t} & \multicolumn{2}{c|}{uint16\_t}       \\ \hline
\textbf{Name}     & \multicolumn{2}{c|}{value1}         & \multicolumn{2}{c|}{value2}         & \multicolumn{2}{c|}{value3}   & \multicolumn{2}{c|}{checksum}        \\ \hline
\textbf{Memory}   & \multicolumn{1}{l|}{8 bits} & 8 bits & \multicolumn{1}{l|}{8 bits} & 8 bits & 8 bits         & 8 bits        & \multicolumn{1}{l|}{8 bits} & 8 bits \\ \hline
\end{tabular}
\caption{Overview of second half of a packet.}
\label{tab:packetTableSecond}
\end{table}

The datatype of the members of \texttt{Packet} are all \texttt{uint16\_t}. This is to ensure that the size of the class does not vary on different architectures. The \texttt{uint16\_t} is always of size 2 bytes. The same size as two characters. Together, all members in the class gives a total size of 16 bytes. The final architecture of a packet can be seen on \ref{tab:packetTableFirst} and \ref{tab:packetTableSecond}.

Only half of the space available in a transmission are occupied as the radio module used in this project supports transmissions of 32 byte at a time. As the solution is designed modular, and the radio module can be replaced with a potentially 'smaller' module in terms of transmission size, the solution would still support this 'smaller' module. Furthermore, a packetsize of 16 bytes is enough to contain the different data collected from the nodes.

\texttt{PacketType} is defined as follows:
\begin{lstlisting}[language=C]
enum PacketType : uint16_t {
    Error,
    DataAcknowledgement,
    DataRequest,
    Data,
    PairRequest,
    PairRequestAcknowledgement,
    ClearSignal
};
\end{lstlisting}


When a \texttt{Packet} is instantiated using the constructor with the \texttt{char *input} as parameter, these values are found using the function \texttt{memcpy}, in the \texttt{decode} function, seen in Listing \ref{lst:decodefunc}.
\begin{lstlisting}[language=C,label={lst:decodefunc},caption={Decode function.}]
void Packet::decode(char *input)
{
    memcpy(this, input, sizeof(Packet));
}
\end{lstlisting}
This copies the memory of the \texttt{char *input} into the memory location where the current \texttt{Packet} object is located. This means that the contents of the packet is set to the content of \texttt{input}.

This is possible as every part of the packet has a known, pre-determined size. \texttt{uint16\_t} always has the same size, not dependant on the architecture running the code. When a packet is encoded, using the \texttt{char *encode()} function, the returned character array is built in the same way, by setting the contents of the array to the contents of the package.

\begin{lstlisting}[language=C]
char *Packet::encode()
{
    char *returnstring;
    returnstring = (char*)malloc(sizeof(Packet));

    memcpy(returnstring, this, sizeof(Packet));

    return returnstring;
}
\end{lstlisting}
The \texttt{encode} function allocates the size necessary for a \texttt{Packet}, but as a \texttt{char *} and uses \texttt{memcpy} to set the contents of the array to the contents of the current \texttt{Packet} and then returning the array. The char array can be seen as a format of the packet object, that can be directly transmitted by the radio module without further operations to the array.

\subsubsection{Checksum}
\texttt{Packet} objects contains a checksum, used to verify the content's integrity. The checksum uses two functions: \texttt{crcInit()} and \texttt{crcCompute(unsigned char *message, unsigned int nBytes)}. The checksum implementation is based on the description in \texttt{Programming Embedded Systems in C and C++} \cite{crcCode}.

The CRC functions share the following data, and this data should be implemented so that it is usable by the functions without instantiating them multiple times and use more memory than necessary.

\begin{description}
	\item[POLYNOMIAL] the generator polynomial by which the message is divided.
	\item[INITIAL\_REMAINDER] the remainder initially appended onto the message before calculating the checksum.
	\item[FINAL\_XOR\_VALUE] the value by which the transfer message is inverted.
	\item[WIDTH] the width of the checksum, which in CRC-16 is 16 bits.
	\item[TOPBIT] is the most significant bit set to 1.
\end{description}

The \texttt{crcInit()} should be run initially to instantiate a table of remainders to expedite the computation of the checksum. The computation is accelerated because the remainder can be calculated byte-wise instead of bit-wise, by the cost of 256 bytes in the memory.  

\begin{lstlisting}[language=C]
void Packet::crcInit()
{
    unsigned short remainder; // 2 byte remainder (according to CRC16/CCITT standard)
    unsigned short dividend;  // What are you?
    int bit; // bit counter

    for(dividend = 0; dividend < 256; dividend++) //foreach value of 2 bytes/8 bits
    {
        remainder = dividend << (WIDTH - 8);//

        for(bit = 0; bit < 8; bit++)
        {
            if(remainder & TOPBIT) // MSB = 1 => divide by POLYNOMIAL
            {
                remainder = (remainder << 1) ^ POLYNOMIAL; //scooch and divide
            }
            else
            {
		        remainder = remainder << 1;//scooch and do nothing (MSB = 0, move along)
	        }
        }
    	Packet::crcTable[dividend] = remainder;//save current crc value in crcTable
    }
}
\end{lstlisting}

The function iterates over all binary combinations of the 16 bits for the dividend. Within this iteration each remainder is initially instantiated by shifting the dividend by 8 bits, as the purpose is to generate 1 byte values. For each of the 8 bits, if the remainders most significant bit is 1, the remainder is divided by the \texttt{POLYNOMIAL} and left shifted one bit. If the most significant bit is 0, the remainder is only left shifted one bit. When all 8 bit computations are finished, the remainder is saved to the \texttt{crcTable} in the current \texttt{dividend}'s position.

However, the main CRC function is the \texttt{getChecksum(unsigned char *message, unsigned int nBytes)}. It utilizes the \texttt{crcTable} and computes and returns the transfer message based on the arguments \texttt{unsigned char *message} and the size of the message \texttt{unsigned int nBytes}.

\begin{lstlisting}[language=C]
uint16_t Packet::getChecksum(unsigned char *message, unsigned int nBytes)
{
    unsigned int offset;
    unsigned char byte;
    uint16_t remainder = INITIAL_REMAINDER;

    for (offset = 0; offset < nBytes; offset++)
    {
        byte = (remainder >> (WIDTH - 8)) ^ message[offset];
        remainder = Node::crcTable[byte] ^ (remainder << 8);
    }
    uint16_t result = remainder ^ FINAL_XOR_VALUE;

    char *toBeSwapped = (char*)malloc(sizeof(char)*2);
    memcpy(toBeSwapped, (char*)&result, sizeof(char)*2);
    char temp = toBeSwapped[1];
    toBeSwapped[1] = toBeSwapped[0];
    toBeSwapped[0] = temp;

    memcpy((char*)&result, toBeSwapped, sizeof(char) * 2);
    free(toBeSwapped);
    return result;
}
\end{lstlisting}


\texttt{getChecksum} uses an \texttt{int offset} to keep track of the iterative progress through the message, a \texttt{char byte} to contain a byte of the \texttt{message} and a \texttt{uint16\_t remainder} instantiated by the \texttt{INITIAL\_REMAINDER} value. 

The function iterates over each byte in the \texttt{message}, according to the algorithm described in Section \ref{cha:crcComp}. The current \texttt{byte} is the remainder right shifted by 8 then XOR'ed with the \texttt{message}'s offset byte. The \texttt{remainder} is then calculated by XOR'ing the value already stored in \texttt{crcTable} at the current byte, with the remainder left shifted by 8. \todo{review explanation}