\subsection{Packet}
The \textit{Packet} class contains the data from a packet received from the radio module. It can be instantiated with a string, or with every part of the packet as a parameter, using the constructors:
\begin{lstlisting}
Packet::Packet(PacketType packetTypeInput, uint16_t addresserInput, uint16_t addresseeInput, uint16_t originInput, uint16_t sensor1Input,
	uint16_t sensor2Input, uint16_t sensor3Input)
	
Packet::Packet(char *input)
\end{lstlisting}


This class is passed around in \textit{Node}, where it is used to determine actions based on the type, or being relayed with some new data. 
The class itself contains the variables:
\begin{lstlisting}
PacketType packetType;
uint16_t addresser;
uint16_t addressee;
uint16_t origin;
uint16_t sensor1;
uint16_t sensor2;
uint16_t sensor3;
uint16_t checksum;
\end{lstlisting}
These values cover everything in a packet; the type, the sender, the receiver, the origin of the packet, values and a checksum.
Every packet has this format, and all values are filled out. With packets that might not require all these values, they will simply be zero. For example when sending a request, the sensor values and addressee will be zero.

\begin{table}[]
\centering
\begin{tabular}{|l|c|l|c|l|c|l|c|l|}
\hline
\textbf{Datatype} & \multicolumn{2}{c|}{Packettype}      & \multicolumn{2}{c|}{uint16\_t}       & \multicolumn{2}{c|}{uint16\_t}       & \multicolumn{2}{c|}{uint16\_t}       \\ \hline
\textbf{Name}     & \multicolumn{2}{c|}{packetType}      & \multicolumn{2}{c|}{addresser}       & \multicolumn{2}{c|}{addressee}       & \multicolumn{2}{c|}{origin}          \\ \hline
\textbf{Memory}   & \multicolumn{1}{l|}{8 bits} & 8 bits & \multicolumn{1}{l|}{8 bits} & 8 bits & \multicolumn{1}{l|}{8 bits} & 8 bits & \multicolumn{1}{l|}{8 bits} & 8 bits \\ \hline
\end{tabular}
\caption{Dataoverview of first half of a packet. The packet can be directly converted to 16 characters.}
\label{tab:packetTableFirst}
\end{table}

\begin{table}[]
\centering
\begin{tabular}{|l|c|l|c|l|c|l|c|l|}
\hline
\textbf{Datatype} & \multicolumn{2}{c|}{uint16\_t}       & \multicolumn{2}{c|}{uint16\_t}       & \multicolumn{2}{l|}{uint16\_t} & \multicolumn{2}{c|}{uint16\_t}       \\ \hline
\textbf{Name}     & \multicolumn{2}{c|}{sensor1}         & \multicolumn{2}{c|}{sensor2}         & \multicolumn{2}{c|}{sensor3}   & \multicolumn{2}{c|}{checksum}        \\ \hline
\textbf{Memory}   & \multicolumn{1}{l|}{8 bits} & 8 bits & \multicolumn{1}{l|}{8 bits} & 8 bits & 8 bits         & 8 bits        & \multicolumn{1}{l|}{8 bits} & 8 bits \\ \hline
\end{tabular}
\caption{Dataoverview of second half of a packet.}
\label{tab:packetTableSecond}
\end{table}

The datatype of the members of \textit{Packet} are all \textit{uint16\_t}. This is to ensure that the size of the class does not vary on different architectures. The \textit{uint16\_t} is always of size 2 bytes. The same size as two characters. Together, all members in the class gives a total size of 16 bytes. The final architecture of a packet can be seen on \ref{tab:packetTableFirst} and \ref{tab:packetTableSecond}.

Only half of the space available in a transmission are occupied as the radio module used in this project supports transmissions of 32 byte at a time. As the solution is designed modular, and the radio module can be replaced with a potentially 'smaller' module in terms of transmission size, the solution would still support this 'smaller' module. Furthermore, a packetsize of 16 bytes is enough to contain the different data collected from the nodes.

\textit{PacketType} is defined as follows:
\begin{lstlisting}
enum PacketType : uint16_t {
    Acknowledgement,
    Request,
    Data,
    PairRequest,
    PairRequestAcknowledgement,
    ClearSignal
};
\end{lstlisting}


When a \textit{Packet} is instantiated using the constructor with the \textit{char *input} as parameter, these values are found using the function \textit{memcpy}, in the \textit{decode} function:
\begin{lstlisting}
void Packet::decode(char *input)
{
    memcpy(this, input, sizeof(Packet));
}
\end{lstlisting}
This copies the memory of the \textit{char *input} into the memory location where the current \textit{Packet} object is located. This means that the contents of the packet is set to the content of \textit{input}.

This is possible as every part of the packet has a known, pre-determined size. \textit{uint16\_t} always has the same size, not dependant on the architecture running the code. When a packet is encoded, using the \textit{char *encode()} function, the returned character array is built in the same way, by setting the contents of the array to the contents of the package.

\begin{lstlisting}[language=C]
char *Packet::encode()
{
    char *returnstring;
    returnstring = (char*)malloc(sizeof(Packet));

    memcpy(returnstring, this, sizeof(Packet));

    return returnstring;
}
\end{lstlisting}
The \textit{encode} function allocates the size necessary for a \textit{Packet}, but as a \textit{char *} and uses \textit{memcpy} to set the contents of the array to the contents of the current \textit{Packet} and then returning the array. The char array can be seen as a format of the packet object, that can be directly transmitted by the radio module without further operations to the array.

\subsubsection{Checksum}
\textit{Packet} objects contains a checksum, used to verify the content's integrity. \todo{Bjørn indsæt CRC implementering her.} The checksum uses two functions: \texttt{crcInit()} and \texttt{crcCompute(unsigned char *message, unsigned int nBytes)}. The checksum implementation is based on the description in \textit{Programming Embedded Systems in C and C++} \cite{crcCode}.

The \texttt{crcInit()} should be run first to generate a table of remainders to expedite the computation of the checksum. The computation is accelerated because the remainder can be calculated byte-wise instead of bit-wise, by the cost of $256 * 2 \text{ bytes} = 512$ bytes. 

\begin{lstlisting}[language=C]
void Node::crcInit()
{
    unsigned short remainder; // 2 byte remainder
    unsigned short dividend; // What are you?
    int bit; // bit counter

    for(dividend = 0; dividend < 256; dividend++) //foreach value of 2 bytes/8 bits
    { 
        remainder = dividend << (WIDTH - 8);//

        for(bit = 0; bit < 8; bit++)
        {
            if(remainder & TOPBIT) // MSB = 1 => divide by POLYNOMIAL
            { 
                remainder = (remainder << 1) ^ POLYNOMIAL; //scooch and divide
            }
            else
            {
                remainder = remainder << 1;//scooch and do nothing
            }
        }
        crcTable[dividend] = remainder;//save current crc value in crcTable
    }
}
\end{lstlisting}
