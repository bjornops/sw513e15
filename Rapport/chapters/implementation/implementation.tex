This chapter contains documentation about the implementation of the protocol designed in Chapter \ref{cha:protocolDesign}. 

First, the classes used in the implementation are shown and explained. Then important parts of the sourcecode are explained.
 

\section{General}
The implementation is written in C++. The development of the solution is done in two man teams, using pair programming. Git is used for version control. The implementation is designed with the requirements of the solution along with the components and choices made in Chapter \ref{cha:designintro}. 

Note that the code in the listings does not necessarily contain the same comments and print statements as in the actual code, to make the code fit onto the pages in the report.

\section{Classes}
The solution contains two different running applications. The main node and the sensor nodes. There are two sets of code due to the different requirements of the nodes. For example, the main node does not have a sensor, as explained in Chapter \ref{cha:workflowDesign}, so it should not be able to handle a sensor, and therefore does not contain the classes used for sensors.

This section contains the classes contained in each application. UML diagrams showing all fields and methods for both main and sensor nodes can be found in Appendix \ref{cha:fulluml}.

\subsubsection*{Main node}
The main node is a Raspberry Pi device, running the Raspbian operating system. The classes in the main node application is seen on Figure \ref{fig:mainnodeClass}. 
According to the specification, the main node pairs nodes, sends requests, and handles received data.

\begin{figure}[h!]
\centering
\includegraphics[width=0.65\textwidth]{chapters/implementation/figures/mainnodeClass.png}
\caption{Classes used in the main node.}
\label{fig:mainnodeClass}
\end{figure}



\subsubsection*{Sensor nodes}
The platforms used for the sensor nodes are Arduino Uno and Mega, although one platform per node. The differences between the two platforms are the pins used for the sensor and radio modules. Besides the pin number, the code is identical on the two platform types. 

The classes used in the nodes are seen on Figure \ref{fig:nodeClass}.
\begin{figure}[h!]
\centering
\includegraphics[width=0.85\textwidth]{chapters/implementation/figures/nodeClass.png}
\caption{Classes used in nodes.}
\label{fig:nodeClass}
\end{figure}


\subsubsection*{Class descriptions}
This section contains explanations about the classes used in the nodes. As the classes are reused on both main and sensor nodes they are only explained once, even though the code may be somewhat different.

\begin{description}
\item[Node] \hfill \\
The \texttt{Node} class is the entry point in the application.
On the sensor node, it contains one or more \texttt{iSensor}s, and a \texttt{iRadio} object that are instantiated when the code is run. The main node contains no sensor, but an \texttt{iRadio} object exists.

The \texttt{Node} class determines what action to take when a packet is received. If data is received from another sensor node that should be relayed, the \texttt{Node} begins sending data until an acknowledgment is received. The methods on the \texttt{iRadio} object is used for listening and sending.
If data is needed for a packet, for example when a request is received, the \texttt{Node} class fetches data from the sensor, and creates the packet that needs to be sent, and makes sure that the data is sent.

\item[iRadio and iSensor] \hfill \\
The \texttt{iSensor} and \texttt{iRadio} interfaces are used to establish a way that all sensors and radio module classes should work. This means that replacing or adding a new sensor or using another radio module is possible, as long as the new component adheres to one of these interfaces. This makes the rest of the code know how to use these components. 

\texttt{iSensor} only contains the method \texttt{int read()}, that returns the value of the sensor. Sensors can contain different methods internally to verify or handle data, but will be required to have the \texttt{read} method.

\texttt{iRadio} contains the methods needed for receiving and sending packets. A special listen method is needed for implementing exponential backoff as the listen function blocks execution and a way of breaking this blocking is needed to not lock the code.
\begin{description}
\item[void broadcast(char *packet)] sends a packet
\item[char *beginListening()] begins listening
\item[char *listenFor(int ms)] begins listening, but stops listening after 'ms' ms
\end{description}

\item[Sensor] \hfill \\
The \texttt{Sensor} class can be used for multiple sensors, as long as the sensor class inherits from \texttt{iSensor}. This class' job is to read data from a sensor on the node, handle this data, and return it to the class that requested this data.

In the solution the sensor class is called \texttt{MoistureSensor}, as a moisture sensor is used. This class can only be found on the sensor nodes, and not on the main node.


\item[NRF24Radio] \hfill \\
The \texttt{NRF24Radio} class handles the radio communication. Classes of this class should inherit from the \texttt{iRadio} interface as the application uses this interface to handle all radiocommunication. The \texttt{NRF24Radio} class returns a \texttt{char} pointer when a packet is received, using one of the listening methods explained in the \texttt{iRadio} section. It is also able to send packets given from other classes, using the \texttt{broadcast} method.

\item[Packet] \hfill \\
The class \texttt{Packet} has the ability to parse a packet from a char\todo{either character og textttttt[char]} array to a \texttt{Packet} object, along with the properties required to further handle the packet. This includes the type, and possibly sensor values, from/to\todo{no slashes in the text!} values or an identifier from the main node.

Instances of this class is created and used in the \texttt{Node} class.\todo{plz stop.}

This class contains the public methods:
\begin{description}
\item[Packet(char *input)] Create a packet from a char array. Used when radio receives a packet.
\item[{\parbox[t]{0.6\linewidth}{Packet(PacketType packetTypeInput, \\ uint16\_t addresserInput, \\ uint16\_t addresseeInput, \\ uint16\_t originInput, \\ uint16\_t value1Input, \\ uint16\_t value2Input, \\ uint16\_t value3Input)}}] \item[] Creates a new packet with data as noted in parameters.
\item[char *encode()] Returns a char array representation of the packet. Used for broadcasting from the radio.
\end{description}

\end{description}


\section{Code}\todo{AAAAHHH!!!!! single lines!?!}
This section contains explanations for some of the important parts of the code.

First, the \texttt{Packet} implementation is explained, with code showing how values are handled and how CRC is implemented.

Second, the \texttt{Node} class is explained along with sensor nodes.

Last, the main node and its interface is explained.

\input{chapters/implementation/packet.tex}
\input{chapters/implementation/node.tex}
\input{chapters/implementation/interface.tex}