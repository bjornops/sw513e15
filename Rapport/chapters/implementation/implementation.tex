This chapter contains documentation about the implementation of the protocol designed in Chapter \ref{cha:protocolDesign}. 

First, the classes used in the implementation are shown and explained. Then important parts of the sourcecode are explained.
 

\section{General}
The implementation is written in C++. The development of the solution is done in two man teams, using pair programming. Git is used for version control.\todo{too short}

Note that the code in the listing does not necessarily contain the same comments and print statements as in the actual code, to make the code 

\section{Classes}
The solution contains two different running applications. The main node and the sensor nodes. There are two sets of code due to the different requirements of the nodes. For example, the main node does not have a sensor, so it should not be able to handle a sensor, and therefore does not contain the classes used for sensors.\todo{elaborate why, refer to design}

This section contains the classes contained in each application. UML diagrams showing all fields and methods for both main and sensor nodes can be found in Appendix \ref{cha:fulluml}.\todo{explain why and how it is developed}

\subsubsection*{Main node}
The main node is a Raspberry Pi device, running the Raspbian operating system. The classes in the main node application is seen on Figure \ref{fig:mainnodeClass}. 
According to the specification the main node pairs nodes, sends requests, and handles receiving and handling data.\todo{wtf er de to sidste?}

\begin{figure}[h!]
\centering
\includegraphics[width=0.65\textwidth]{chapters/implementation/figures/mainnodeClass.png}
\caption{Classes used in the main node.}
\label{fig:mainnodeClass}
\end{figure}



\subsubsection*{Sensor nodes}
The platforms used for the sensor nodes are Arduino Uno and Mega, although one platform per node. The differences between the two platforms are the pins used for the sensor and radio modules. Besides the pin number, the code is identical on the two platform types. The sensor nodes handles receiving and sending requests, reading and sending sensor data, and relaying data through nodes until they arrive at the main node. \todo{already described in design. aka we know this. explain why and how, or why it's relevant.}

The classes used in the nodes are seen on Figure \ref{fig:nodeClass}.
\begin{figure}[h!]
\centering
\includegraphics[width=0.85\textwidth]{chapters/implementation/figures/nodeClass.png}
\caption{Classes used in nodes.}
\label{fig:nodeClass}
\end{figure}


\subsubsection*{Class descriptions}
This section contains explanations about the classes used in the nodes.\todo{Enough. I've had it with these motherfuckings single sentences in these motherfucking paragraphs.}

\begin{description}
\item[Node] \hfill \\
The \textit{Node} class is the entry point in the application.
It contains one or more \textit{iSensor}s, and a \textit{iRadio} object that are instantiated when the code is run.

The \textit{Node} class determines what action to take when a packet is received. This happens in the method \texttt{void determineAction(char* packet)}.\todo{does code belong in the general description?}
If data is received from another sensor node that should be relayed, the \textit{Node} begins sending data until an acknowledgment is received. The methods on the \textit{iRadio} object is used for listening and sending.
If data is needed for a packet, for example when a request is received, the \textit{Node} class fetches data from the sensor, and creates the packet that needs to be sent, and makes sure that the data is sent.

\item[iRadio and iSensor] \hfill \\
The \textit{iSensor} and \textit{iRadio} interfaces are used to establish a way that all sensors and radio module classes should work. This means that replacing or adding a new sensor or using another radio module is not a problem\todo{reformulate or source...}, as the rest of the application knows that the radio is able to send and receive data, and the sensor is able to return a value. 
It is not necessary to know how it is done, only that it is possible. These interfaces are used to set a standard on how to communicate with them, whether it is a moisture sensor or a pH sensor.\todo{language cleanup}

Every type of radio or sensor added to the node must inherit from these interfaces.\todo{...}


\textit{iSensor} only contains the method \textit{int read()}, that returns the value of the sensor.\todo{...}

\textit{iRadio} contains the methods:\todo{missing context and reasoning}
\begin{description}
\item[void broadcast(char *packet)] sends a packet
\item[char *beginListening()] begins listening
\item[char *listenFor(int ms)] begins listening, but stops listening after 'ms' ms
\end{description}

\item[Sensor] \hfill \\
The \textit{Sensor} class can be used for multiple sensors, as long as the sensor class inherits from \textit{iSensor}. This class' job is to read data from a sensor on the node, handle this data, and return it to the class that requested this data.

In the solution the sensor class is called \textit{MoistureSensor}, as a moisture sensor is used. This class can only be found on the sensor nodes, and not on the main node.


\item[Radio] \hfill \\
The \textit{Radio} class handles the radio communication. Types\todo{instantiations?} of this class should inherit from the \textit{iRadio} interface.\todo{why?} The \textit{Radio} class returns an array of char pointers when one is received\todo{why?}. It is also able to send packets given from other classes\todo{why?}.

\item[Packet] \hfill \\
The class \textit{Packet} has the ability to parse a packet from a char\todo{either character og textttttt[char]} array to a \textit{Packet} object, along with the properties required to further handle the packet. This includes the type, and possibly sensor values, from/to\todo{no slashes in the text!} values or an identifier from the main node.

Instances of this class is created and used in the \textit{Node} class.\todo{plz stop.}

This class contains the public methods:
\begin{description}
\item[Packet(char *input)] Create a packet from a char array. Used when radio receives a packet.
\item[{\parbox[t]{0.6\linewidth}{Packet(PacketType packetTypeInput, \\ uint16\_t addresserInput, \\ uint16\_t addresseeInput, \\ uint16\_t originInput, \\ uint16\_t value1Input, \\ uint16\_t value2Input, \\ uint16\_t value3Input)}}] \item[] Creates a new packet with data as noted in parameters.
\item[char *encode()] Returns a char array representation of the packet. Used for broadcasting from the radio.
\end{description}

\end{description}


\section{Code}\todo{AAAAHHH!!!!! single lines!?!}
This section contains explanations for some of the important parts of the code.

First, the \texttt{Packet} implementation is explained, with code showing how values are handled and how CRC is implemented.

Second, the \texttt{Node} class is explained along with sensor nodes.

Last, the main node and its interface is explained.

\input{chapters/implementation/packet.tex}
\input{chapters/implementation/node.tex}
\input{chapters/implementation/interface.tex}