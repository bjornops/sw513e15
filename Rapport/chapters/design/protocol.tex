\section{Protocol design}
%META
\todo{be more humble, analytic and include possibilities or explain why omitted}
To transmit the data from the nodes to the main node, there has to be some sort of protocol. The protocol must support the utilized hardware components and be designed to work within their limitations. The network is supposed to be controlled by the main node, and the nodes will transmit sensor data on demand\todo{why?}.

The protocol to be developed for the solution will be based on the examination of networks in section \ref{fig:topologies} and the protocols described in section \ref{cha:comprot}, and adapted to fit the requirements. There are a number of considerations to be made to develop a protocol that complies to the requirements. Because the sensor nodes are battery driven, most of the choices are done with power consumption as a priority, to increase the battery longevity.\todo{add to requirements?}

While the individual nodes have a relatively short communication range, a network of these devices can have a longer reach if the nodes are able to relay data. Therefore, relaying must be supported by the protocol. 

\subsection{Transfer method and topology}
The solution must gather sensor data from all nodes in the network, and this subsection will contain the considerations made for the choice of topology.

According to a requirement found in \ref{cha:requirements}, there is no demand to measure one specific node at a time. This leads to the data readings can be done for all nodes at the same time. 

There are multiple methods to request data from the network nodes, some of the most used ones can be found in \ref{cha:comprot}. 
\iffalse
One method can transmit a data request to every node in the network, by addressing it by name. This would require the main node to create an individual request to each node in the network, and the network nodes to know the path through the network to the addressee, so that the request can be relayed correctly. This is not appropriate when the network nodes have limited memory\todo{how much would routing tables fill?}. In case of disconnected nodes, the routing tables must be reconfigured, to make sure packets are relayed in a path that does exist. This would accordingly require nodes to somehow broadcast that they are still alive, and thereby consume more energy.
\fi

The method that is worked around in the project is the flooding protocol.
Which is a method where the data request can be transmitted by flooding the network without sending a tailored request to each node. A flooded request will broadcast to all nodes in the network, and will only require one request packet. If the broadcast is done by controlled flooding, there will be no cycles, and the outgoing transmit topology will consequently be a tree. The flooding will not utilize much data, while it is one packet only, but the controlling of the flooding can use more processing power, as the nodes can receive the same packet multiple times and must analyze and discard any previously received packets.

The controlled flooding has a low memory impact and thus best suited for the solution. The flooding protocol will create a tree which can be utilized to create a return path for the nodes' sensor readings.

The tree created in each request broadcast can be different, based on interference, removed or faulty nodes or by other reasons. This will effectively solve the requirement of respond appropriately to a disconnecting node as well as including new nodes in the network. It will also use the shortest paths to 

A process to add new nodes could be to pair a node with the main node before placing it in the network. This way, a node could have assigned a unique identity to be able to recognize its sensor readings from other sensors. 
The protocol is described more indepth in \ref{cha:floodingSec}

%Appropriate response to a disconnecting node could be handled by a mesh network, by bypassing or finding another route to the main node, but a mesh network \todo{uses more energy? more data? Argue why bad.} is badder. 


%Instead of having a static tree where the nodes have permanent parents and children, the tree is restructured for each new data request from the main node. 
%This is done by flooding the network from the main node to create a temporary spanning tree, where each node remembers its parent for the current data request\todo{find name for an instance of data gather/request}. 
%This solves the issues of a defective node, since it will not be part of the tree. 

\subsection{Data}

\textbf{What data?}\newline
The data to be transmitted is..

\textbf{Precision/allocation}

\subsection{Transfer speed}
Faster transfer speed uses more energy, but in a shorter amount of time. Slower transfer speed uses less energy, but over longer time. What is best?

\subsection{Interference}
When using a flooding protocol, interference can become a problem, as explained in section \ref{cha:floodingSec}. This occurs even when using controlled flooding, but using a protocol can help reduce problems with interference.

Interferences might cause packets to get mixed up, which makes it impossible to use the data received. Figure \ref{fig:prottree1} shows an example of possible interference. Nodes 5, 6, and 7 could send packets at the same time, causing node 3 to get scrambled data.

To ensure this is not a problem, a checksum is used for verifying packets. This checksum is transmitted with the data and recipient. When a node receives a packet, this checksum is calculated, and compared to the one in the packet. If the checksums match, the packet is accepted and can be relayed to the next node. This will cause the receiving node to send an acknowledgment to the node that sent the packet, which will then stop sending data.
If the checksums does not match, the packet is ignored until a 'clean' packet makes it way to the node.

To ensure that a 'clean' packet will arrive at some point, the nodes will wait a random, but longer, interval between attempting to send data. This means that at some point, the data will get through to the receiver, without interference.
This is possible, as time is not of the essence, and the delay between trying again is small.

\textbf{Exponential backoff}\newline
\textbf{Other handling of interference?}

\subsection{Overloaded nodes}
Nodes near the root transfers data for a lot of sensors. Can they handle it? Battery problems?

\subsection{Sequence}
\begin{enumerate}
	\item Receive data request (Wireless request for nodes, user input at the main node)
		\subitem Ignore if (already received or not recipient of package)
	\item Remember parent (MN skip)
	\item Acquire sensor data
	\item Send sensor data to parent (if silence?)
	\item Receive acknowledgment of sent package
	\item Send data request to all
	\item Receive data from children
	\item If no response or acknowledgment within 10 min: (deep) sleep?
\end{enumerate}

%which has a main node, called the root, and multiple branches and leaves. \todo{why?} The nodes in the tree does not necessarily connect directly to the main node, but relay information through nodes, which is necessary due to the short range of the radio modules used in the solution.


\textbf{Example}\newline
The protocol uses flooding to distribute the data request through the network. 
When data is requested by the user, the main node sends a packet containing a sensor reading request. 
The nodes that receive this packet directly from the main node is the first level of nodes in the tree, as seen in figure \ref{fig:prottree1}. 
These nodes then read the moisture values from their sensors and transmit these back to the main node. 

The first level nodes then request data from the nodes within their range. 
The nodes receiving this request firstly verifies that it is a new request, then registers the node that requested data as its parent. 
These nodes are second level nodes. The second level nodes read from the sensors, and sends data back to their parents. The parents then relay the data to the main node. 
This procedure continues until all reachable sensors have relayed data back to the main node.
An illustration showing an example of a tree is seen on Figure \ref{fig:prottree1}.

For each new data request from the main node the tree structure and node levels are assessed again as they might have changed, due to new or disconnected nodes.

\begin{figure}[!h]
	\centering
	\makebox[\textwidth][c]{\includegraphics[width=1\textwidth]{chapters/design/figures/prottree1.png}}
	\caption{Example of a tree.}
	\label{fig:prottree1}
\end{figure}

\textbf{Adding and removing nodes}\newline
If a new node is added to the network, it needs an identifier in the system so that its sensor reading can be recognized. The identifier is permanent for the node until it is reassessed, and it is attached to every packet sent by the node.
The identifier is provided by the main node by pairing the device with the main node before adding it to the network. 

The identifier is additionally used to address parent nodes to relay the packets when transmitting sensor data. In figure \ref{fig:prottree1}, the nodes 5, 6, and 7 would send and address packets to the parent by the identifier 3. This means that other nodes in the vicinity would ignore these packets, and only node 3 reacts on the packets. Node 3 would then relay the data to node 2, as 2 is 3's parent, and finally 2 would relay to MN.

Should a node somehow disconnect from the network, the nodes connected to this node will receive the packets from another node, and from that point on use that as the parent. This is \todo{NO FUCKING "OF COURSE"!!} if there are any nodes in range of the disconnected nodes' subnodes. 

\begin{figure}[!h]
	\centering
	\makebox[\textwidth][c]{\includegraphics[width=0.8\textwidth]{chapters/design/figures/prottree2.png}}
	\caption{Example of a where node 3 disconnected.}
	\label{fig:prottree2}
\end{figure}

An example of this can be seen on Figure \ref{fig:prottree2}. This figure shows how node 3 disconnected, and now node 7 is attached to node 4 instead. This, of course, assumes that node 7 was in range of node 4.
This means that the next time data is requested, node 7 will be the parent for node 5 and 6, and they will now be a level higher than before.


