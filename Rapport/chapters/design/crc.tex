\todo{Agree upon packet terminology}
\section{Checksum}
%Why checksum
Wireless communication is prone to noise and shit\cite{source}. To be able to discern correct packets from incorrect packets, a detection method is necessary. There are multiple ways to verify a packet's integrity and this section will contain description of some methods and reasoning of the selected solution.

\subsection{Definition and types}
%What is a checksum
A checksum is a unique value that can be used to verify that a message is received correctly \cite{datapakke}. The checksum is based on all parts of the message and unique to the resolution of the checksum. 
A single bit checksum can only distinguish between two messages, and is not able to verify with more than 50 \% accuracy, as an error could affect the transferred message so that the checksum calculation still produces the same checksum.

%What kind of checksum
Checksums can variate by multiple properties, either by how it is calculated or by its length. 

\textbf{Digit sum}\newline
A simple algorithm for producing a checksum is to use the digit sum and store it in a byte. This algorithm is efficient, but has multiple flaws, therein the uniqueness of the checksum of only 256 values and that two bit flips could cancel each other out and cause the same checksum. The error detection level is regarded as too small, and the this algorithm will not be used in the protocol.

\textbf{MD5}\newline
MD5 is a widespread checksum algorithm. It produces a 128 bit checksum, which is 16 bytes. MD5 is designed to run efficiently on 32 bit processors, which is a disadvantage on the Arduino boards used in the solution, that have 8 bit processors. The 16 byte checksum uses half of the possible payload of the NRF24L01, and makes the protocol less scalable to other systems. The MD5 algorithm is therefore discarded as the checksum generator. \cite[p.~308]{boyles2010ccna}.

\textbf{Cyclic redundancy check}\newline
Another checksum algorithm is cyclic redundancy check/code, hereafter referenced to as \textit{CRC}. This exists in several forms, based on the parameters. The checksum size is variable as well as internal algorithm parameters. CRC can detect single error, more than a single error and burst error \cite[p.~31]{elahi2001network}. The CRC meets the criteria for the solution, hence the selected checksum generator is CRC.

\subsection{Computation of a checksum}
%Calculation of a checksum
The algorithm for generating a CRC checksum is described in this subsection.
In short, the CRC executes a division of the message on a fixed polynomial, and the remainder is the checksum. 

A message $M$ is viewed as a polynomial with binary coefficients, by treating each character in $M$ bit-wise. This makes for a relatively large number, but the decimal equivalent is irrelevant for the computation. M's length in bits is called $m$, which in example in \tabref{string} is 24.

\begin{table}[h!]
	\centering
	\begin{tabular}{ll}
		String  & CRC                        \\
		Binary  & 01000011 01010010 01000011 \\
		Decimal & 4,411,971                  \\
		Polynomial & $x^{22} + x^{17} + x^{16} + x^{14} + x^{12} + x^{10} + x^{6} + x^{1} + x^{0}$
	\end{tabular}
	\caption{String equivalents}
	\label{tab:string}
\end{table}

To generate an $r$ bit checksum it is required a generator polynomial of degree $r$. The generator polynomial 






% notes
r bit CRC checksum requires degree r generator polynomial.
m bit message

M = polynomial representation of the message(binary)
R = polynomial representation of the remainder calculated by the sender
Q = quotient discarded, as only R is necessary

Sent message (transmitted data) = Mx$^r$ - R

Mx$^r$ = QG + R
% /notes



\subsection{Verification of a message}
%Verification of a message
The received message is verified by doing one of the two following methods. 

Generate checksum of message m and compare with received checksum r.
The checksum of a correctly transferred packet t is 0.